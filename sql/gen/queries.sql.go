// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package sqlc

import (
	"context"
)

const addJournalEntry = `-- name: AddJournalEntry :one
INSERT INTO debt_journal (
    amount, description, user_id
) VALUES (
    $1, $2, $3
) RETURNING id, amount, description, date, user_id
`

type AddJournalEntryParams struct {
	Amount      int64
	Description string
	UserID      int32
}

func (q *Queries) AddJournalEntry(ctx context.Context, arg AddJournalEntryParams) (DebtJournal, error) {
	row := q.db.QueryRow(ctx, addJournalEntry, arg.Amount, arg.Description, arg.UserID)
	var i DebtJournal
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.UserID,
	)
	return i, err
}

const addPlayer = `-- name: AddPlayer :one
INSERT INTO player (
    discord_id, discord_name, guild_id, name
) VALUES (
    $1, $2, $3, $4
) RETURNING id, discord_id, discord_name, guild_id, name
`

type AddPlayerParams struct {
	DiscordID   string
	DiscordName string
	GuildID     string
	Name        string
}

func (q *Queries) AddPlayer(ctx context.Context, arg AddPlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, addPlayer,
		arg.DiscordID,
		arg.DiscordName,
		arg.GuildID,
		arg.Name,
	)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.DiscordID,
		&i.DiscordName,
		&i.GuildID,
		&i.Name,
	)
	return i, err
}

const deleteBotSetup = `-- name: DeleteBotSetup :exec
DELETE FROM bot_setup
WHERE guild_id = $1
`

func (q *Queries) DeleteBotSetup(ctx context.Context, guildID string) error {
	_, err := q.db.Exec(ctx, deleteBotSetup, guildID)
	return err
}

const deleteJournalEntry = `-- name: DeleteJournalEntry :exec
DELETE FROM debt_journal
WHERE id = $1
`

func (q *Queries) DeleteJournalEntry(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteJournalEntry, id)
	return err
}

const deletePlayer = `-- name: DeletePlayer :exec
DELETE FROM player
WHERE id = $1
`

func (q *Queries) DeletePlayer(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePlayer, id)
	return err
}

const doesBotSetupExist = `-- name: DoesBotSetupExist :one
SELECT EXISTS(SELECT 1 FROM bot_setup WHERE guild_id = $1)
`

func (q *Queries) DoesBotSetupExist(ctx context.Context, guildID string) (bool, error) {
	row := q.db.QueryRow(ctx, doesBotSetupExist, guildID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const doesPlayerExist = `-- name: DoesPlayerExist :one
SELECT EXISTS(SELECT 1 FROM player WHERE discord_id = $1 AND guild_id = $2)
`

type DoesPlayerExistParams struct {
	DiscordID string
	GuildID   string
}

func (q *Queries) DoesPlayerExist(ctx context.Context, arg DoesPlayerExistParams) (bool, error) {
	row := q.db.QueryRow(ctx, doesPlayerExist, arg.DiscordID, arg.GuildID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAllBotSetups = `-- name: GetAllBotSetups :many
SELECT guild_id, channel_id, registration_message_id, debts_message_id, created_at FROM bot_setup
`

func (q *Queries) GetAllBotSetups(ctx context.Context) ([]BotSetup, error) {
	rows, err := q.db.Query(ctx, getAllBotSetups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BotSetup
	for rows.Next() {
		var i BotSetup
		if err := rows.Scan(
			&i.GuildID,
			&i.ChannelID,
			&i.RegistrationMessageID,
			&i.DebtsMessageID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPlayers = `-- name: GetAllPlayers :many
SELECT player.id, player.discord_id, player.discord_name, player.guild_id, player.name, debt.id, debt.amount, debt.last_updated, debt.user_id, debt_journal.id, debt_journal.amount, debt_journal.description, debt_journal.date, debt_journal.user_id FROM player
JOIN debt ON player.id = debt.user_id
JOIN debt_journal ON player.id = debt_journal.user_id
WHERE guild_id = $1
`

type GetAllPlayersRow struct {
	Player      Player
	Debt        Debt
	DebtJournal DebtJournal
}

func (q *Queries) GetAllPlayers(ctx context.Context, guildID string) ([]GetAllPlayersRow, error) {
	rows, err := q.db.Query(ctx, getAllPlayers, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllPlayersRow
	for rows.Next() {
		var i GetAllPlayersRow
		if err := rows.Scan(
			&i.Player.ID,
			&i.Player.DiscordID,
			&i.Player.DiscordName,
			&i.Player.GuildID,
			&i.Player.Name,
			&i.Debt.ID,
			&i.Debt.Amount,
			&i.Debt.LastUpdated,
			&i.Debt.UserID,
			&i.DebtJournal.ID,
			&i.DebtJournal.Amount,
			&i.DebtJournal.Description,
			&i.DebtJournal.Date,
			&i.DebtJournal.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBotSetup = `-- name: GetBotSetup :one
SELECT guild_id, channel_id, registration_message_id, debts_message_id, created_at FROM bot_setup
WHERE created_at = (SELECT MAX(created_at) FROM bot_setup) AND bot_setup.guild_id = $1 LIMIT 1
`

func (q *Queries) GetBotSetup(ctx context.Context, guildID string) (BotSetup, error) {
	row := q.db.QueryRow(ctx, getBotSetup, guildID)
	var i BotSetup
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.RegistrationMessageID,
		&i.DebtsMessageID,
		&i.CreatedAt,
	)
	return i, err
}

const getIdOfPlayer = `-- name: GetIdOfPlayer :one
SELECT id FROM player
WHERE discord_id = $1 AND guild_id = $2 LIMIT 1
`

type GetIdOfPlayerParams struct {
	DiscordID string
	GuildID   string
}

func (q *Queries) GetIdOfPlayer(ctx context.Context, arg GetIdOfPlayerParams) (int32, error) {
	row := q.db.QueryRow(ctx, getIdOfPlayer, arg.DiscordID, arg.GuildID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getJournalEntries = `-- name: GetJournalEntries :many
SELECT id, amount, description, date, user_id FROM debt_journal
WHERE user_id = $1
`

func (q *Queries) GetJournalEntries(ctx context.Context, userID int32) ([]DebtJournal, error) {
	rows, err := q.db.Query(ctx, getJournalEntries, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DebtJournal
	for rows.Next() {
		var i DebtJournal
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayer = `-- name: GetPlayer :many
SELECT player.id, player.discord_id, player.discord_name, player.guild_id, player.name, debt.id, debt.amount, debt.last_updated, debt.user_id, debt_journal.id, debt_journal.amount, debt_journal.description, debt_journal.date, debt_journal.user_id FROM player
JOIN debt ON player.id = debt.user_id
JOIN debt_journal ON player.id = debt_journal.user_id
WHERE player.discord_id = $1 AND player.guild_id = $2
`

type GetPlayerParams struct {
	DiscordID string
	GuildID   string
}

type GetPlayerRow struct {
	Player      Player
	Debt        Debt
	DebtJournal DebtJournal
}

func (q *Queries) GetPlayer(ctx context.Context, arg GetPlayerParams) ([]GetPlayerRow, error) {
	rows, err := q.db.Query(ctx, getPlayer, arg.DiscordID, arg.GuildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayerRow
	for rows.Next() {
		var i GetPlayerRow
		if err := rows.Scan(
			&i.Player.ID,
			&i.Player.DiscordID,
			&i.Player.DiscordName,
			&i.Player.GuildID,
			&i.Player.Name,
			&i.Debt.ID,
			&i.Debt.Amount,
			&i.Debt.LastUpdated,
			&i.Debt.UserID,
			&i.DebtJournal.ID,
			&i.DebtJournal.Amount,
			&i.DebtJournal.Description,
			&i.DebtJournal.Date,
			&i.DebtJournal.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const numberOfPlayers = `-- name: NumberOfPlayers :one
SELECT COUNT(discord_id) FROM player
`

func (q *Queries) NumberOfPlayers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, numberOfPlayers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const putBotSetup = `-- name: PutBotSetup :one
INSERT INTO bot_setup (
    guild_id, channel_id, debts_message_id, registration_message_id
) VALUES (
    $1, $2, $3, $4
) RETURNING guild_id, channel_id, registration_message_id, debts_message_id, created_at
`

type PutBotSetupParams struct {
	GuildID               string
	ChannelID             string
	DebtsMessageID        string
	RegistrationMessageID string
}

func (q *Queries) PutBotSetup(ctx context.Context, arg PutBotSetupParams) (BotSetup, error) {
	row := q.db.QueryRow(ctx, putBotSetup,
		arg.GuildID,
		arg.ChannelID,
		arg.DebtsMessageID,
		arg.RegistrationMessageID,
	)
	var i BotSetup
	err := row.Scan(
		&i.GuildID,
		&i.ChannelID,
		&i.RegistrationMessageID,
		&i.DebtsMessageID,
		&i.CreatedAt,
	)
	return i, err
}

const setDebt = `-- name: SetDebt :exec
INSERT INTO debt (amount, user_id)
VALUES ($1, $2)
ON CONFLICT (user_id)
DO UPDATE SET amount = $1, last_updated = now()
WHERE debt.user_id = $2
`

type SetDebtParams struct {
	Amount int64
	UserID int32
}

func (q *Queries) SetDebt(ctx context.Context, arg SetDebtParams) error {
	_, err := q.db.Exec(ctx, setDebt, arg.Amount, arg.UserID)
	return err
}

const updateJournalEntry = `-- name: UpdateJournalEntry :one
UPDATE debt_journal
SET amount = $1, description = $2
WHERE id = $3
RETURNING id, amount, description, date, user_id
`

type UpdateJournalEntryParams struct {
	Amount      int64
	Description string
	ID          int32
}

func (q *Queries) UpdateJournalEntry(ctx context.Context, arg UpdateJournalEntryParams) (DebtJournal, error) {
	row := q.db.QueryRow(ctx, updateJournalEntry, arg.Amount, arg.Description, arg.ID)
	var i DebtJournal
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.UserID,
	)
	return i, err
}
